============================================================================
     AIMS Ver 1.90                                     (c) D.N.A. Softwares
============================================================================


■ はじめに

  このプログラムは、「D.N.A. Softwares」で使用しているゲームエンジンです。
  特徴として
  ・DirectX描画ライブラリ「Luna」を独自改造した高速な描画
  ・スクリプトエンジン「Lua」を利用した汎用的な開発
  が可能となっています。
  営利非営利問わず無償でご利用いただけます。
  販売・配布の際には一報いただけると幸いです。(連絡先は巻頭のWebサイトより)

  動作環境
    OS     : Windows XP/Vista/7(それぞれ、x86/x64いずれでも起動します)
    CPU    : Pentium 4以降
    MEMORY : 2000/XP 256MB以上・Vista 512MB以上
    HDD    : 100MB以上
    VIDEO  : DirectX 9に対応したグラフィックボード

  これはAIMSが起動する最低動作環境です。
  スクリプトの記述内容や使用するリソース、PC環境などの要因により変動します。

■ フォルダの内容

  bin\        AIMSのバイナリ。AIMSd.exeがデバッグ、AIMS.exeがリリース。
  docs\       AIMSの簡易マニュアルなど
  packer\     配布時にリソースを梱包するためのキット。詳しくはフォルダ内txtを。
  proto\      開発用のプロトタイプ
  utils\      開発を支援するユーティリティ群
  readme.txt  このファイル


■ ゲーム配布時の注意事項

  このエンジンでは以下のプログラム/ライブラリを利用しています。
  
  ・DirectX9.0c用ライブラリ"Luna"
  ・Ogg Vorbis
  ・Mersenne Twister
  ・Lua, LuaJIT
  
  配布の際には各ライブラリのライセンステキストを同梱してください。
  （docs\license.txtを再利用してもかまいません）

■ インストール・アンインストール

  解凍し、適当なフォルダにコピーしてください。
  アンインストールする際はフォルダを削除してください。
  AIMSはレジストリを使用していません。


■ 起動オプション

  AIMS.exeには、以下のオプションを渡すことができます。

    --vsync, -v             VSYNCのみで描画を行います。
    --double, -d            表示解像度を2倍にします。
    --width, -w             指定した数値の高さで起動します。
    --height, -h            指定した数値の幅で起動します。
    --fullscreen            強制的にフルスクリーンで起動します。
    --windowed              強制的にウィンドウモードで起動します。
    --nostop                非アクティブ時に停止しません。
    --console               デバッグコンソールを表示します。
    --log                   リリースビルドにおいて、ログ出力をさせます。
    --logfilename, -l       デバッグHTMLのファイル名指定。
    --nolog                 ログ出力を行いません。(デバッグ用ビルド時有効)
    --frameskip             処理落ちする際にフレームスキップを行います。
    --titlebar              AIMSのタイトルバーにdebugOut文の出力を出します。


■ エンジンの構成について

  AIMSは以下の手順で起動します。

  1.設定ファイル読み込み
    「実行ファイル名.lua」という設定ファイルを読み込みます。
    実行ファイル名を変更した場合は、この設定ファイルの名前も変更してください。
    （AIMSd.exeを利用する場合などに気をつけてください）

  2.boot.lua
    ゲーム本体の初期化や、スクリプトファイルのrequireはここで行います。

  3.common.lua
    各種共通関数が記載されています。
    boot.lua内の最初に読み込む（prequire）してください。


■ 簡易リファレンス
  AIMSにはLuaスクリプトエンジンを採用しているため、
  Luaで定義されている関数郡は全て利用可能です。

  1.シーンという概念
    AIMSは「ベースシーン」「追加シーン」という2つのシーン概念があります。
    ベースシーンはゲームの基本となるシーンです。
    追加シーンは、ベースシーンの上もしくは下に作成されるシーンです。
    
    動作シーンには「Scene_OnStart()」「Scene_OnStep()」「Scene_OnClose()」という
    3つの関数が最低でも必要となります。
    また、呼び出しの際には「_On〜」より手前の英字を指定します。
    呼び出された直後に「OnStart」が実行されます。
    次のフレームからは、内外から終了されるまで「OnStep」がループ実行されます。
    内外から終了指示を受けた場合「OnClose」が実行されメモリから解放されます。
    
    各シーンには12枚のレイヤーが用意されてます。
    レイヤーごとにオブジェクトの描画が行われます。
    
    シーンの動作を変更する関数は以下のとおりです。

    ・changeScene( SceneTag );
      自分自身の動作シーンをSceneTagに切り替えます。
      実行すると、SceneTag_OnStartが実行されます。
    
    ・SceneID = addScene( SceneTag[, Index] );
      SceneTagという新しい動作シーンを作成します。
      実行すると、SceneTag_OnStartが実行されます。
      
      SceneIDは作成した動作シーンの値が格納されます。
      Indexは1または2を指定します。
      0をベースシーンとし、数字が大きいほど上に表示されます。
    
    ・closeScene( [SceneID] );
      SceneIDに指定された追加シーンを終了します。
      指定が無い場合は自分自身のシーンを終了します。
      実行すると、SceneTag_OnCloseが実行されます。

  基本的には
  「ゲームの中心的な内容をベースシーンで実行」
  「PRGのメニューやSTGのスコア表示を追加シーンで実行」
  という使い方が主だった使い方になりますが、
  管理が煩雑になりやすいため慣れるまではベースシーンのみで実行するのが
  望ましいと思います。
  
  
  2.アクター
    AIMSでは「画面上に表示されるオブジェクト」のことをアクターと呼びます。
    各アクターには以下の関数が用意されています。
    
    ・hActor = createActor( hGraphic, x, y[, angle, speed], layer[, func]);
      画面上で描画されるアクターを作成します。
      angleとspeedが定義された場合、作成された次のフレームから
      指定された値で動作を開始します。
      layerには0〜11までの値を入力します。
      
      funcが指定された場合「func_OnStart()」が実行されます。
      次のフレームから、フレームごとに「func_OnStep()」が実行されます。
      アクターの破棄が行われると「func_OnClose()」が実行されます。

    ・addMover( hActor, wait, loop, MOVER_TAG, TAG_A, TAG_B);
      hActorに外部から処理を行います。
      アクターが自分自身を参照する場合はiSelf()を指定します。
      （iSelf()は自分自身のアクターハンドルを返す関数です）
      
      MOVER_TAGにはさまざまな命令が定義されています。
      命令によってTAG_A、TAG_Bの指定内容が変化します。
      代表的な命令は以下のとおりです。
      
      MOVER_SETPOSITION, X, Y
        アクターを指定した座標に移動します。
      
      MOVER_SETANGLE, ANGLE
        アクターの移動角度を設定します。
        画面上での表示もこのANGLEに依存します。
      
      MOVER_SETSPEED, SPEED
        アクターを指定したSPEEDで移動させます。
        移動方向はアクターが保持しているANGLEに依存します。
      
      MOVER_SETALPHA, ALPHA
        アクターの透明度を設定します。
        0で表示なし、255で100%となります。
      
      MOVER_ADDALPHA, ADDALPHA
        アクターの透明度を段階的に変更します。
        loopで指定されたフレーム数分、透明度を増減します。
      
      MOVER_SETVANISH
        アクターを消滅させます。
      
      
   3.Music
     いわゆるBackGroundMusic。
     
     ・playMusic(intro_filename[, loop_filename]);
     ・playMusicLoop(intro_filename[, loop_filename]);
       指定されたoggファイルを再生する。
       再生順は「intro_filename -> loop_filename」となり、
       playMusicLoopの場合loop_filenameを無限ループ再生する。
       （loop_filenameが定義されていない場合はintro_filenameをループする）
     
   4.Sound
     いわゆるSoundEffect。
     
     ・hSound = loadSound( filename );
       指定されたファイルをロードしハンドルを取得する
     ・playSound( hSound );
       指定されたハンドルのSEを再生する。
   
   5.各種入力
     DirectInputを利用して入力を取得することができます。
     
     以下の定数が利用可能です。
       BUTTON_UP
       BUTTON_DOWN
       BUTTON_LEFT
       BUTTON_RIGHT
       BUTTON_TRIG1
       BUTTON_TRIG2
       BUTTON_TRIG3
     
     
     ・bool result = isJoyPressed([UserID, ]trigger_id);
       trigger_idに対応したキーが押されているか取得する。
       UserIDが指定されていない場合は自動的に0が定義される。
     
     ・int count = getJoyPressCount([UserID, ]trigger_id);
       trigger_idに対応したキーが押されているフレーム数を取得する。
       押された直後のみ反応したい場合などに使用する。
     
   
   6.その他
     ゲーム制御や開発時に必要となる関数群
     
     ・debugOut( string[, view] );
     ・_dm( string[, view] );
       ウィンドウタイトルとログにstringの内容を出力する。
       viewにfalseが定義されている場合はログ出力は行わない。
       変数の内容を表示したい場合、tostring(string)とすることで
       booleanやnilも表示される。
     
     ・quit();
       エンジンを終了する。
     
     ・str = serialize( table );
       配列をテキスト化する。
     
     ・table = deserialize( string );
       テキストを配列に組み上げなおす。
     
     ・saveFile(filename, string);
       stringの内容を指定されたfilenameに保存する。
     
     ・string = loadFile(filename);
       stringに指定されたfilenameの内容を代入する。
     
   


■ 最後に

  バグを発見した場合はご報告ください。

  本パッケージにはLunaライブラリの作者、葉迩倭氏によるLuna用ユーティリティの一部
  ・LPACK
  ・LLZSS
  ・FontUtil
  ・LagUtil
  を同梱しています。転載自由とのことですので、本パッケージに同梱いたしました。

■ 改版履歴

2014/02/13 v1.91b
　・かなり致命的なバグが１点見つかったので修正。

　●修正
　・スレッド（コルーチン）を複数アクターで動作させている場合、コルーチンがGCに巻き
　込まれて途中消滅（し、結果として不正終了）することがあったのを修正。

2014/01/11 v1.91
　・激しく間が開いてしまい申し訳ありません。メッセージパッシング部分にあったバグの
　　修正を行っています。
　
　●修正
　・LuaJITを2.0.2に更新
　・sendMessageで戻り値が得られないバグを修正。
　・テクスチャフォントにおいて、未定義の文字におけるGetStringLastPosPの文字送りと、
　　DrawStringExの文字送りで値が異なっていたのを修正。
　　上記に起因して右寄せ・センタリングが正しく働いてないことがあったのを修正
　・エラー表示位置がたまにおかしな場所を指していたのを修正。
　・drawTextureFontおよび文字列アクターの「\acRRGGBBAA」記法で指定した色について
　　元のアルファ値の影響を受けるように修正（RGBは影響なし）
　　実際使っててこのような仕様にしないと困る局面があったので、変更しました。
　　
　●仕様変更
　・OnStep等で使われるコルーチンを極力新規生成せず使い回すように変更。
　　コルーチンの新規生成コストってバカにならんのでは？ということで変更しました。
　　外向きの挙動は変わりませんがエラー表示で関数名が出ないことがあります。
　　本当はデバッグ用と本番用で実装を変えておくべきなのかもしれませんが……

　●機能追加・変更
　・getEnv 関数追加。環境変数を得る
　　var = getenv("name");
　　
　・IMEシーンで入力中の文字列の折り返しに対応。startIMEInputExを使う。
　　startIMEInputEx(x,y,テクスチャフォントハンドル[,最大長[,"初期文字列"
　　 [,折り返し幅px
　　 [,文字R,G,B[,変換前文字R,G,B[,変換中文字R,G,B[,カーソルR,G,B]]]]]]]);
　　 ……という風に指定できます。
　・テクスチャフォントについてY方向オフセット YOffset を実装
　（たまにテクスチャフォントで上が余ることがあったので
　　createTextureFont("lfdfilename","extention"[,isPropotional[,YOffset]]);
　・フォントの行高さ lineHeight を指定できるようにした（単位px）
　　createTextureFont("lfd",".png"[,isPropotional[,spacing[,yoffset[,lineHeight]]]]);
　
　●今後について
　　激しく間が開いてしまったのには理由がありまして、ここしばらくは描画系に大幅に
　　手を入れたAIMS2.0系統の制作を行っておりました。メジャーバージョンが変わること
　　でお察し頂けるかとも思いますがかなりの点で互換性がない（単純な置換でない大幅な
　　手修正を求める）アップデートになる見通しです。一部有用な機能追加もあるので、1.9
　　系統に追加できる機能は可能な限り追加していきたいとは思っていますが、原則として
　　以後1.9系統はメンテナンスを主体として進行していくとご理解ください。
　　
　　なお、2.0系統はマニュアルの大幅変更が避けられない見通しなのと、まだ開発を行い
　　ながら機能検証を実施している段階ですので、公開には今しばらくお時間を頂くことに
　　なるかと思います。


2013/03/10(SVN掲載) v1.90
　・寝ている間にv1.81がWeb掲載されてしまったのですが微妙に不具合が残っている
　　バージョンだったので更新します。問題なさそうならWebにも載せます。

　●重要な変更（１）
　　LuaJITを2.0.0にしました。これにともない、Luaスクリプト本体に関する仕様が一部
　　追加・変更となります。
　　具体的にはオリジナルのLua5.2の追加機能が一部実装されているとのことです。
　　以下、LuaJITにある追加事項一覧を簡単に訳したもの。lua5.2マニュアルも
　　参照ください。AIMSではあまり関係ないと思われるところは省略しています。
    ・goto と ::labels:: の追加。
    ・文字列で '\x3F'(16進コード指定) や '\*' の形式のエスケープのサポート追加
    ・load関数の新構文。
    　　load(string|reader, chunkname [,mode [,env]])
      loadstring()と同等の事がload関数でもできるようになり、loadstringは
      load関数のエイリアスになっています。（loadstringは廃止予定）
    ・math.log10の廃止。かわりにmath.logが基数指定に対応。
      math.log(x [,base]) math.log(x,10) でmath.log10(x)の代わりになります。
    ・string.rep(s, n [,sep]) 第3引数で区切り文字列を指定可能に。
    ・string.format()において %s の文字列変換に __tostringメタメソッドを
      使うようになりました。また、%aと%Aに対応。
    ・文字クラスで %g(空白を除く全ての印刷可能文字) を追加.
    ・io.read("*L")のサポート。*lと違い、改行を保持。 
    ・io.lines() と file:lines() でも io.read()同様に書式指定に対応。
    
    一般的なスクリプトでは互換性周りの問題は発生しないと思いますが、math.log10
    など地味に廃止になった関数もありますので、導入前には十分確認をお願いします。
    一応、幻想麻雀3Gやワルプルギスでは特に問題無く移行しています。
    
　●重要な変更（２）
　　エラー表示を変更しました。可能な限り、スタックトレース（呼び出し履歴）を表示
　　するようにしています。
　　ただ、特にAIMS関数でのエラーにおいてエラーメッセージと共に表示されるエラー
　　発生地点が正しい場所を示さなくなっております。
　　スタックトレースを見ればエラー発生位置は特定できるようになっていますので、
　　当面はスタックトレースを見て対処頂くようお願いします。
　　
　●重要な変更（３）
　　Moverの要素が増えたのですが、内部処理の都合により、一部の動作要素の定数が
    変更になっています。詳しくは後述「・Mover拡張」の「※互換性に関する注意」を
    ごらんください。
　　
　●修正
  ・解放し忘れの各種ハンドルがあった場合、終了時にランタイムエラーが発生する事が
    あったのを修正

  ●機能追加
  ・文字表示周り強化
    テクスチャフォントでのみ使用可能だった正しい行揃え指定、縦アライメント、折り
    返し指定がASCIIフォントでも使用可能になりました。また、表示するテキストに混ぜ
    て使えるコントロールコードを追加。文中での色変更ができます。
    "\acRRGGBBAA"（RR,GG,BB,AAはそれぞれRGBA値を16進で）……描画色を変更
    "\asRRGGBBAA"（同上）……描画スペキュラ色を変更（テクスチャフォントのみ）

    例："\acff8080ffSCORE:\acffffffff0"→ 明るい赤で「SCORE:」のあと白字で「0」 

  ・BigIntクラス
    色々と必要に駆られたためLuaの数値を超える大きい整数を扱うクラスを用意しまし
    た。
    long long型へのインタフェースとなっており、一応 -2^63〜+2^63 の範囲が扱える
    はずです。(およそ±922京の範囲)
    ちょっと制限があるので使用時は注意してください。

    local a = BigInt:new("12345678901234"); -- デカい数値を初期化するなら文字で
    local a = BigInt("12345678901234"); --この書き方もよし
    a:Set("1234567890123456"); -- 代入（=での代入は数値型で上書きしてしまう）
    a:Add(30); -- a+=30 他に :Dec :Mul :Div がある
    local b = BigInt:new(200); --もちろん数値でも初期化できる
    a:Mul(b); -- a*=200 BigIntクラスを喰わせてもいい
    a = a / b; -- a = a / 200 当然この記法でもいい
    a = a / 25.5 -- 小数を喰わせてもいい（小数部は切り捨て）

    local c = a:Mod(b) -- aをbで割った余りを返す。戻り値cもBigIntクラス

    _dm(a:ToString()) -- 文字列に変換するにはToString();
    num = Get(); -- 数値型に変換するにはGet();
    -- doubleの仮数部で表現できる範囲を超えた数値の場合は精度落ちが発生します

    ==と~=はBigInt型同士および、BigIntと数値型での比較ができます。
    大小比較はBigInt型同士でなければいけません。

    コード例は上の続きとして、
    if a < 900000 then hogehoge(); end --←エラーになる
    if a < BigInt(900000) then hogehoge(); end --←これならOK

  ・isHitActor関数拡張
  　戻り値を2個追加、ヒットした矩形の、「自分」と「相手」のフラグ値を同時に返す
    ようにしました。戻ってくるフラグはそれぞれ、当たっていた矩形のフラグ値です。
    （複数の当たり判定矩形とヒットしていた場合は、それぞれの矩形のフラグのうち
    最大のものが返ります）
　・getHitLayerEx関数を追加
    上記拡張に対応したgetHitLayerの拡張。構文自体はgetHitLayerと同じですが、
    ヒットしたアクターハンドルだけでなくそれぞれの矩形のフラグ値も一緒に
    返すようにしました。具体的な戻り値の構造は下記。
    
    local t = getHitLayerEx(actor,layer)
    として当たり判定をとったとき、
    t={
      { アクターハンドル,自分のフラグ,相手のフラグ };
      { アクターハンドル,自分のフラグ,相手のフラグ };
      { アクターハンドル,自分のフラグ,相手のフラグ };
      .....
    };
    
  ・createActor関数の第1引数にテーブルを指定できるようになった
    setGraphicAnimeSequenceとかの都合でG.hoge.fuga[1]って指定することが多いと
    思います。最後の[1]をよく忘れるので、いっそ、ということで
    「G.hoge.fuga」と指定した場合、G.hoge.fugaがテーブルだったならば
    G.hoge.fuga[1]を参照するようにしました。
    
  ・メッセージパッシング機構（あるいはメソッドコール）

    アクターやシーンに対して外部から指示を出すのに有用かと思いましてこんな関数を
    用意しました。特に自分以外のシーンに対しての指示はグローバル変数などを
    使うほかなかったと思いますので、これでだいぶスマートな書き方が出来るんじゃ
    ないかと期待しています。
  
    １．hActorで示すアクターがクラス hoge で動いているとき、
      sendMessage(hActor,"message",args...);
      で、関数hoge_messageを呼ぶ。引数はargsの全部が渡る。
      hoge_message内ではiSelf()はhActorを指す。
      またhoge_messageの戻り値はすべてsendMessageの戻り値として伝搬する。
    ２．hSceneで示すシーンがクラス fuga で動いているとき、
      sendSceneMessage(hScene,"message",args....);
      で、関数hoge_messageを呼ぶ。引数はargsの全部が渡る。
      hoge_message内ではiSelf(),iThisScene()はhSceneを指す。createActorも
      hSceneのシーンに対して行われる。
      sendMessage同様、戻り値はすべてsendSceneMessageの戻り値として伝搬する。

    なおメソッドに対応する関数が無かった場合でもエラーにはならないので、
    チェックが必要な場合は戻り値がnilかどうかで判定するとよいかと思います。
    
  ・Mover拡張
  
    Moverの要素が大幅に増えました。今回の目玉は「MOVER_***TO」関連の強化です。

    ※互換性に関する注意
    下記要素は定数定義が変更になっています。基本addMoverの要素指定は定数を使って
    いるとは思いますが、何らかの理由で定数を使っていない場合下記の要素がズレます
    ので、心当たりがある場合はご確認をお願いします。
    
    MOVER_ZOOMTO_L=31           -- 指定拡大率に変化(線形)
    MOVER_ZOOMTO_A=32           -- 指定拡大率に変化(加速)
    MOVER_ZOOMTO_B=33           -- 指定拡大率に変化(ブレーキ)
    MOVER_ZOOMTO_C=34           -- 指定拡大率に変化(両方)
    MOVER_INVERT_OBCHECK=36     -- 画面外判定処理をレイヤー設定と逆にする
    MOVER_LINK=37               -- リンク設定
    MOVER_UNLINK=38             -- リンク設定解除
    MOVER_SETVAR=39             -- 値スロットに数値を設定
    MOVER_ADDVAR=40             -- 値スロットに数値を加算(減算)
    MOVER_SETOBCHECK=41         -- 画面外判定処理を強制設定
    MOVER_SETSPECULAR=42        -- スペキュラ色設定

    １．MOVER_***TOで変化できるパラメタの増加
    
    MOVER_COLORTO_L=43          -- 指定RGB値に描画色をフェード(線形)
    MOVER_COLORTO_A=44          -- 指定RGB値に描画色をフェード(加速)
    MOVER_COLORTO_B=45          -- 指定RGB値に描画色をフェード(ブレーキ)
    MOVER_COLORTO_C=46          -- 指定RGB値に描画色をフェード(両方)
    MOVER_SPECULARTO_L=48       -- 指定RGB値にスペキュラ色をフェード(線形)
    MOVER_SPECULARTO_A=49       -- 指定RGB値にスペキュラ色をフェード(加速)
    MOVER_SPECULARTO_B=50       -- 指定RGB値にスペキュラ色をフェード(ブレーキ)
    MOVER_SPECULARTO_C=51       -- 指定RGB値にスペキュラ色をフェード(両方)
    MOVER_ALPHATO_L=53          -- 指定値にαをフェード(線形)
    MOVER_ALPHATO_A=54          -- 指定値にαをフェード(加速)
    MOVER_ALPHATO_B=55          -- 指定値にαをフェード(ブレーキ)
    MOVER_ALPHATO_C=56          -- 指定値にαをフェード(両方)
    MOVER_ROTATETO_L=58         -- 指定角度に回転(線形)
    MOVER_ROTATETO_A=59         -- 指定角度に回転(加速)
    MOVER_ROTATETO_B=60         -- 指定角度に回転(ブレーキ)
    MOVER_ROTATETO_C=61         -- 指定角度に回転(両方)
    MOVER_HEADTO_L=63           -- 指定の見た目角度に回転(線形)
    MOVER_HEADTO_A=64           -- 指定の見た目角度に回転(加速)
    MOVER_HEADTO_B=65           -- 指定の見た目角度に回転(ブレーキ)
    MOVER_HEADTO_C=66           -- 指定の見た目角度に回転(両方)

    上記の通り、回転角や描画色、アルファもフェードできるようになりました。
    
    ２．フェードのパラメータ変化カーブを関数で与えられるようになった（イージング）
    
    MOVER_ZOOMTO_F=35     -- 指定拡大率に変化(イージング関数使用)
    MOVER_COLORTO_F=47    -- 指定RGB値に描画色をフェード(イージング関数使用)
    MOVER_SPECULARTO_F=52 -- 指定RGB値にスペキュラを変化(イージング関数使用)
    MOVER_ALPHATO_F=57    -- 指定値にαをフェード(イージング関数)
    MOVER_ROTATETO_F=62   -- 指定角度に回転(イージング関数)
    MOVER_HEADTO_F=67     -- 指定の見た目角度に回転(イージング関数)

    これらの要素を指定した場合はaddMoverの最終パラメタにイージング関数名を指定
    しなければなりません。最新のcommon.luaの最後に「ease****」という関数が
    ごっそり増えていますので、ソレを指定して頂くことになります。
    
    例：addMover(iSelf(),0,60,MOVER_ZOOMTO_F,5,5,"easeOutBack");
    ※startThreadなどのように文字列指定となりますのでご注意ください。
    
    イージング関数はjQueryのやつを元に作成しました。関数名も同じにしています
    ので、実際どんな値変化をするかは下記のjQuery用の説明をごらんください。
    関数名とその関数が描く値変化グラフを一覧で見ることができます。
    http://hosted.zeh.com.br/tweener/docs/en-us/misc/transitions.html
    
    なお、MOVER_***_Fはアクタークラスを割り当ててないアクターであっても
    適用可能となっております。念のため。
    
  ・9patch対応の描画命令
    9patchとは画像を３×３の９枚に分割し、カドは拡大せず中心と4辺のみを拡大する
    ことで輪郭部分など「拡大されると不自然になる」部分はそのままにしつつ、様々な
    サイズのボタンやウィンドウなどを描画する手法のことです。
    ゲームにおいてもメッセージウィンドウの描画など、利用局面は多いと思います。
    東方幻想麻雀3Gでは各種ダイアログのボタンの描画に9Patchを使っています。
    これまではLuaコードで実装していましたが、AIMSの機能に格上げすることに
    しました。
    
    アクターで9Patchを使う場合はVAR[64]の特殊描画指定を使います。
    VAR[64]に4〜6を指定し、下記のように各箇所に対応するハンドルをVARで
    セットします。
    
    左上
    　[65] [66] [67]
    　[68]  ※  [69]
    　[70] [71] [72]
    　　　　　　　右下
    
    四隅 65,67,70,72は拡大縮小なし。
    上下サイド66,71は横拡大、左右サイド68,69は縦拡大。
    中心部分は周りのサイズに応じて拡大/縮小されます。
    VAR[64]が4の時は描画基準座標が左上に、5の時は中心に、6の時は右下にセット
    されます。必要に応じてご選択ください。

    中心（※）はアクターのグラフィックハンドルが使われます。
    MOVER_SETFACEで設定してください。
    
    OnDrawの中でも9Patch描画ができます。
    
    drawGraphic9patch(hImage1,hImage2,...,hImage9,
        x,y,w,h[,cr,cg,cb,ca[,blend[,sr,sg,sb,sa]]]);
    drawGraphic9patch(hImageTable,x,y,w,h[,cr,cg,cb,ca
        [,blend[,sr,sg,sb,sa]]]);
        
    hImage1〜9は9Patchの左上、上、右上、左、真ん中、右、左下、下、右下を
    順番に指定。hImageTableならこれらを[1]から順に[9]までに収めたテーブルを
    指定すればよし。
    x,y,w,hは左上座標と幅高さ、cr,cg,cb,caが描画色、blendはブレンド、
    sr,sg,sb,saはスペキュラ色の指定です。

    9Patch用の画像切り出しはcutGraphicで頑張ってください、というにはあまりに
    めんどくさいので、common.luaにサポート関数を足しておきました。
    
    cut9PatchGraphic(g,x,y,w1,w2,w3,h1,h2,h3)
    cut9PatchGraphic2(g,x,y,w,h,w_left,h_top,w_right,h_bottom)
    
    あと、アクターへの9Patch画像の割り付けを行う関数もあります。
    set9patchGraphic(hActor,tbl)
    
    それぞれ詳しくはcommon.luaのコメント参照で。
    
  ・シーン全体のαを指定するsetSceneAlpha関数と
  　そのαを取得するgetSceneAlpha()関数追加

    setSceneAlpha([hScene,]alpha);
    alpha = getSceneAlpha([hScene]);

    alpha は0〜255。drawGraphicなども影響を受けます。
    
　・指定テクスチャの任意領域から画面の任意領域へ描画する
    drawGraphicRectToRect関数追加

    drawGraphicRectToRect(hImageTexture,sx,sy,sw,sh,
        dx,dy,dw,dh[,r,g,b,a[,blend[,sr,sg,sb,sa]]]);
    
    hImageTextureで指すテクスチャの左上(sx,sy)サイズ(sw,sh)の矩形の範囲を
    切り出して、画面の左上(dx,dy)サイズ(dw,dh)からなる矩形に転送します。
    地味に便利。
    描画色はr,g,b,aで指定。blendはブレンドの指定、sr,sg,sb,saはスペキュラ。
    
2012/11/28(SVN掲載) v1.81
  ・さすがにあんまりなバグがあったので急ぎ更新。
  ●修正
  ・getTextWidth関数を引数2個で呼んだときに限り戻り値がおかしかったのを修正。
  ・グラフィック、サウンド、テクスチャフォント（BISHAMONエフェクト）の参照カウン
    タに不具合があり、参照が残っている状態で各リソースが消滅することがあった不具
    合を修正。
  ・（AIMS+BISHAMON）奥行きのある（Z方向に広がる）BISHAMONエフェクトについてZ<0
    の部分がまったく描画されてなかったのを修正。

2012/11/14(SVN掲載) v1.80
  ・かなり間ｇ（ｒｙ）
    いくつか頂いていた機能追加要望、および、今後必要になりそうな機能のうち皆さん
    の役に立ちそうなものを搭載したバージョンです。
    一部定数が増えたためcommon.luaも更新となりました。

  ●重要な変更
    ローダースレッド周りに大幅な変更が入りました。
    これまではLuaコードを丸ごと別スレッドで動作させていたのですが、メインスレッド
    のメモリ空間にアクセスしてしまいLuaが異常終了する事例が発生しておりました。
    スレッドセーフでないLuaを無理矢理マルチスレッド動作させていたのが悪い、という
    ことで、今回ローダースレッドの処理を大幅に変更しました。

    具体的には下記のような挙動に変更となります。
    ・startLoaderThreadを呼ぶとメインスレッドのままローダー関数を呼ぶ。
    ・ローダー関数内ではloadGraphic,loadSound,createTextureFontを呼んでもその場で
      は読み込まない。ファイルを「後で読みこむ」リストに積むだけ。
    ・ローダー関数を抜けた後、「後で読みこむ」リストのファイルを実際に読み込む
      スレッドを起動。このスレッドが終わったら読み込み完了。

    ややこしい流れですが、コーディング自体は今までと変わりません。startLoaderThread
    を読んだ後、isLoaderRunning()がtrueの間ループで待機、でOKです。
    いくつかパフォーマンスに関わる注意事項があります。
    ・ローダー関数内でgetGraphicClipRectなど「画像を読み込んでみないと結果が
      返せない」関数を呼んだ場合はその場で画像をロードします。エラーにはなりませ
      んが、別スレッドでの読み込みにならないので、画面がちょっと止まるかもしれま
      せん。可能な限り、これらの関数はローダー関数の後で使いましょう。ローダー
      関数内で画像を読み込まざるを得なかった場合はdebug.htmlで報告されます。
      途中読み込みが発生する可能性のある関数は下記の通りです。
      getGraphicClipRect、getGraphicCenterX/Y、getGraphicRCenterX/Y
    ・ローダー関数をメインスレッドで動作させる都合、ローダー関数内に余りにも重い
      処理を突っ込むと普通にメインの処理が止まってしまいます。ご了承ください。
      ロード以外で重い処理を行う場合はコルーチンで負荷を分散させることをご検討
      ください。

    ・AIMS+BISHAMONご利用の方はBISHAMONエフェクトも遅延ロードの対象になります。

  ●機能追加
    ■テクスチャフォント周りの大幅強化
    個人的にv1.80の目玉です。まだASCIIフォントの方が機能アップについてきていませ
    んが、テクスチャフォントの強化だけでも十分使えると判断して公開いたします。
    １．テクスチャ文字列アクターの拡大縮小、回転が可能になった
    MOVER_SETZOOMやら、MOVER_TURNHEADINGやらで姿勢を変えるとちゃんと追従します。
    ２．テクスチャ文字列は縦方向アライメントを設定できるようになった。
    common.luaにこんな感じで定義が増えてます。
        VALIGN_TOP      = 0; --上端揃え
        VALIGN_CENTER   = 1; --センタリング
        VALIGN_BOTTOM   = 2; --下端揃え

    すべて改行つき文字列にも追従するようになっています。
    ３．テクスチャ文字列は複数行になった文字列でも横方向アライメントを適切に処理
    できるようになった。
    これまではセンタリングなどは1行の文字列でなければおかしくなっていましたが、
    各行ごとに適切にセンタリングなり右寄せなりができるようになっています。
    ４．テクスチャ文字列については1行あたり横幅を指定できるようになった。
    長い文字列も指定幅を超える場合は強制的に折り返しが行われます。。

    これによりcreateTextActorの引数が増えたほか、drawTextureFontの強化版として
    drawTextureFontEx関数ができました。
    
      createTextActor(フォントハンドル,"文字列",X,Y,レイヤー[,R,G,B,A
        [,文字揃え横[,ブレンド指定[,文字揃え縦]]]][,"クラス名"])
      ※文字揃え縦を指定しなかった場合、文字揃え横による挙動はこれまで通りとなり
        ます
      ※折り返し幅は作ったアクターの値スロット65番にセットしてください。
      0で折り返しなし。

      drawTextureFontEx(フォントハンドル,X,Y,"文字列",R,G,B,A[,文字間隔[,文字揃え横
        [,文字揃え縦[,回転角度[,折り返し幅[,X拡大倍率,Y拡大倍率]]]]]]);
      ※拡大した場合、折り返し幅も拡大倍率に応じて広がります。

    ■CMatrixクラス(4x4行列)、CVector3クラス(3次元ベクトル)の正式公開
    今回のバージョンアップでどうしても必要になったので公開機能とします。取り回し
    がややめんどくさかったりまず使わない機能があったりしますが、C++のクラスを丸
    ごと引き出しただけなので勘弁してください。

    ・CMatrixクラス
        matrix = CMatrix:new(); --新規CMatrixクラスを返す。

        matrix:Get( i, j ); -- i行j列の値を得る
        matrix:Set( i, j, Data ); -- i行j列に値Dataをセット。

        matrix:Identity(); -- 単位化

        matrix:Transpose(); -- 転置
        matrix:Inverse(); -- 逆行列化
        matrix:Normalize(); -- 正規化
        matrix:Multiply( CMatrix ); --matrixにCMatrixを乗算

        matrix:RotationX( Angle ); -- X軸で回転する行列を生成。以下Y軸、Z軸。
        matrix:RotationY( Angle );
        matrix:RotationZ( Angle );
        matrix:RotationZXY( AngleX, AngleY, AngleZ ); -- Z,X,Yの順で回転させる行
        列を生成
        matrix:RotationAxis( Angle, CVector3 ); -- CVector3クラスで示されるベク
        トルを回転軸とした回転行列を生成
        matrix:Rotation( rotx, roty, rotz ); -- XYZの順に回転させる行列を生成
        matrix:Scaling( sx, sy, sz ); -- スケーリング行列を生成
        matrix:Translation( px, py, pz ); -- 移動行列を生成
        matrix:Perspective( fov, near_z, far_z, aspect ); -- 透視変換行列
        matrix:Ortho( w, h, near_z, far_z ); -- 平行投影行列

        matrix:LookAt( vector3_Eye, vector3_At, vector3_Up ); -- 注視行列生成。
        全てCVector3を与える

        matrix:Delete() --破棄。

    ・CVector3クラス
        v3 = CVector3:new([x, y, z]); --ベクトルクラス初期化。
        v3.x -- X成分 変数みたいにアクセスできる。
        v3.y -- Y成分
        v3.z -- Z成分

        v3:Add( in1, in2 ); -- in1/2は共にCVector3 入力した2ベクトルの和をv3にセット
        v3:Sub( in1, in2 ); -- in1からin2を減じた結果をv3にセット
        v3:Set( fPx, fPy, fPz ); -- ベクトル設定

        v3:LengthSq(); -- 長さの2乗を返す
        v3:Length(); -- 長さを返す。
        v3:DotProduct( in ); -- inはCVector3(これから先のinも同じ)
                             -- v3とinとの内積を返す

        v3:Normalize(); -- 正規化

        v3:CrossProduct( in ); -- v3とinとの外積を返す
        v3:Reflect( in ); -- v3とinとの反射ベクトルを返す
        v3:TransformNormal( matrix ); -- matrixはCMatrix 指定の行列で法線変換
        v3:TransformCoord( matrix ); -- 指定の行列で座標変換
        v3:TransformProjection( matrix ); -- 指定の行列で透視変換

        v3:RotationX( angle ); -- X軸回転 回転角の単位はdegree
        v3:RotationY( angle ); -- Y軸回転
        v3:RotationZ( angle ); -- Z軸回転
        v3:RotationAxis( angle, vaxis ); -- vaxis(CVector3)を軸に回転
        v3:Rotation( rotx, roty, rotz ); -- x,y,z軸の順に回転
        v3:Scaling( sx, sy, sz ); -- スケーリング
        v3:Translation( px, py, pz ); -- 移動

        v3:Delete(); -- 破棄。

        このほかに、CVector3同士なら加算と減算が、
        数値型との乗算、除算が使えます。

    ■レイヤーごとのアフィン変換行列設定、パース補正設定
    レイヤーに対して描画時に座標変換をかけられるようになりました。
    レイヤー全体の回転、拡大縮小など、アフィン変換でできる変形は全てできるように
    なります。アフィン変換はZ値にも影響しますが、Zソートは変換前のZで行われるた
    め、Z方向へ極端な回転などをかけた場合は前後順がおかしくなるかもしれません。

    アフィン変換行列を与えるには setLayerAffineTrans関数を使います。

      setLayerAffineTrans(レイヤー番号,有効フラグ(true/false)[,変換行列(CMatrix)]);
      有効フラグtrueの場合は変換行列の指定必須、falseの場合は不要。

    また、アフィン変換の実装と一緒に、Z値に応じたパース補正もできるようにしまし
    た。パース補正を加えることで奥行きのある回転が実現できます。

      setLayerPerspective(レイヤー番号,有効フラグ(true/false)[[,中心X,中心Y],
                            パース補正値]);
      パース補正値はZ値が+4095のとき何分の一に縮小されるかを指しています。
      普通は2.0〜4.0くらいでそれっぽく見えます。
    ※Zに-4096など負方向に大きな値を与えると描画座標が反転してしまいますので注意。

    ※AIMS+BISHAMONご使用の方へ、BISHAMONエフェクトはまだパース補正に対応してい
    ません。アフィン変換には追従します。予めご了承ください。

    以下アフィン変換とパース補正のコード例。
    (640x480の画面で、あるレイヤーにY軸45度の回転を与える)
        local mtx = CMatrix:new(); 
        local mtx2 = CMatrix:new(); 
        mtx:Identity(); --単位行列セット
        mtx2:Translation(-320,-240,0); -- 画面中心を原点に動かす
        mtx:Multiply(mtx2);
        mtx2:RotationY(45); -- Y軸45度回転
        mtx:Multiply(mtx2);
        mtx2:Translation(320,240,0); -- 元の位置に戻す
        mtx:Multiply(mtx2);

        setLayerAffineTrans(1,true,mtx);
        setLayerPerspective(1,true,4);

    なお大変大事なことですが、アフィン変換・パース補正しても当たり判定矩形は
    アフィン変換されません。どういうことかというと、異なる座標変換を適用された
    2レイヤー間では当たり判定が見た目通りにならん、ということです。全く同じよう
    にアフィン変換・パース補正を入れたレイヤー同士であれば当たり判定は見た目通り
    になっているように見えます。(それでもZ値の違いが考慮されませんのでまだ不自然
    になることがあります)基本、演出用の機能だとお考えください。
    (やろうと思えばナ●コのア●ルトもどきぐらいはできるかもしれません)

    ■FPS取得とフレームシンクロ無視（全速駆動モード）設定
    getFPS() でFPSが取れるようになっています。
    また、setFastForward(true) で全力駆動モードに入ります。
    ただし、デフォルトのフレーム待ち方式（VSYNC+タイマー）では全力駆動はできま
    せん。全力駆動モードを使う場合はアプリケーションコンフィグでVSYNCを切る設
    定を行って(USE_VSYNC = 0 を追加)ください。

    全力駆動を停止する場合はsetFastForward(false)で。

2012/05/30(SVN掲載) v1.70
  ・かなり間が空いてしまいましたがそれなりに関数が増えてきたので一旦公開します。
    「ワルプルギス  円環の迷宮」で使用しているバージョンです。
    common.luaも変更されていますので、そちらの更新もお忘れ無く。

  ●新機能追加
    ■スペキュラ色指定
    アクターの描画時にスペキュラ色が適用できるようになりました。グラフィックの色
    に、指定したRGB値を「加算」して描画します。今までの描画色指定では元の色と同
    じか、それ以下に暗くすることしかできませんでしたが、スペキュラの導入で光らせ
    るような演出もできるようになると思われます。
    現時点では通常アクターのみ対応。それなりに負荷の高い処理とされていますので、
    レイヤー単位での有効・無効が設定できるようにしてあります（初期状態ではオフ）
    以下の手順で有効にします。

    １．レイヤーに対しスペキュラ使用設定を行う
      例：setLayerUseSpecular(0,true) -- レイヤー0番のスペキュラON
    ２．アクターを生成し、addMoverでスペキュラ色を設定
      例：addMover(a,-1,1,MOVER_SETSPECULAR,0,255,0)
           -- ↑アクターaにスペキュラ色(0,255,0)を設定

    ■キャラクターマップ新形式とマップエディタの変更
    キャラクターマップの読み込み形式として新しく「VMF1」形式を制定しました。レイ
    ヤーごとにマップサイズを設定できるようになり柔軟性が増した他、レイヤーごとに
    タグとして任意の文字列を関連づけることができます（タグ機能については、エディ
    タ側は近日対応予定です。）現時点のマップエディタではVMF1形式のエクスポートが
    可能です。(FMF形式のエクスポートも引き続きサポートしています)
    VMF1形式のマップはloadVMF()関数で読み込めます。VMF形式では得られるテーブルの
    構造がFMFと違うのでご注意ください。具体的には下記のようになっています。

    vmf = loadVMF("hoge.vmf"); としたとき、
    vmf.layerCount ... レイヤー枚数。(1〜)
    vmf.data[0〜(layerCount-1)] ... レイヤーデータ
    vmf.data[n].width  ... レイヤーnのマップ幅
    vmf.data[n].height ... レイヤーnのマップ高さ
    vmf.data[n].tag    ... レイヤーnのタグ文字列
    vmf.data[n][0〜(width*height-1)] ... レイヤーnのデータ実体

    dataテーブルごとに幅、高さが入り、代わりにvmf直下のmapWidth mapHeightが無く
    なっていますので、VMF1形式への移行の際は注意してください。

    ■MOVERの新規要素 (v1,v2,v3 = 種別に続く引数1,2,3)
        MOVER_LINK=35        -- リンク設定(指定アクターとの位置関係を維持)
                             -- (v1 = リンク先アクターハンドル)
        MOVER_UNLINK=36      -- リンク設定解除
        MOVER_SETVAR=37      -- 値スロットに数値を設定(v1=スロット v2=値)
        MOVER_ADDVAR=38      -- 値スロットに数値を加減算(v1=スロット v2=加減値)
        MOVER_SETOBCHECK=39  -- 画面外判定処理を強制設定(v1=設定を示す定数)
        MOVER_SETSPECULAR=40 -- スペキュラ色の設定(v1,2,3 = R,G,B)

        -- MOVER_SETOBCHECK で valueに与える定数
        OB_DEFAULT=0            -- レイヤーの設定に従う
        OB_FORCE_ON=1           -- レイヤーの設定にかかわらず画面外消滅ON
        OB_FORCE_OFF=2          -- レイヤーの設定にかかわらず画面外消滅OFF

    ■高速描画時のブレンディング
      いままでは通常ブレンド固定でしたが、setLayerUseFastDraw関数の第3パラメタに、
      ブレンド方法を指定する新オプションを追加しました。当然、レイヤーの全アクタ
      ーがここでの設定に従って描画されます。

  ●新規関数追加
    ・isMusicPlaying()
        ストリームが再生中か返す。
    ・setDrawOutlineBox([hActor,]flag[,r,g,b,a])
        指定アクターのグラフィックの外枠を描画。flagがtrueで描画、
        その後の4パラメタは枠色指定。
    ・drawDefaultGraphic()
        OnDrawファンクション内から「普通のアクターグラフィック」を描画させる。
        OnDrawを通さなかったときのアクターの見た目に等しい。
    ・getOldX([hActor]) getOldY([hActor])
        指定アクターの1フレーム前の座標を返す。(省略時自分自身)
    ・getDiffX([hActor]) getDiffY([hActor])
        指定アクターの1フレーム前の座標と今の座標との差を返す。(省略時自分自身)
    ・getHitLayerPoint(layer,x,y[,ignoreInvisibleCount])追加。
        layer内のアクターのうち、当たり判定矩形が座標(x,y)を含むアクターを返す。
        ignoreInvisibleCount をtrueにすると当たり判定無視フラグを無視する
          (＝常時すべてのアクターを判定) デフォルトではfalse

    このほか、common.luaにいくつかお役立ち関数を追加しています。

  ●既存関数の仕様変更
    ・setLayerUseFastDraw
      第三パラメータを追加。高速描画時のブレンドモードを指定できる。
      ブレンド定数 BLEND_* を指定のこと。

  ●不具合修正とか
    ・drawGraphicList関数を何度も呼んでいるとそのうちメモリ不足に陥る不具合を
      修正。

  ●ツール(/utils/)の追加・更新
    ・ピクチャアセンブラをとりあえず追加しました。(/utils/PictureAssembler/PictureAssembler.exe)
      複数の画像ファイルを1枚の画像にまとめたり、1枚の画像から複数のグラフィック
      を切り出し、PNG出力とLuaコードの出力を同時に行います。まだ説明書がありませ
      んが近々用意します。
    ・マップエディタ更新。
      VMF1形式への対応がメインです。

  ●アーカイブ(SVN)の変更点
    ・プロトタイプ(/proto/)のAIMS.exeは開発用バージョンなのに、bin/のAIMS.exeは
      リリース版、ということでかなり紛らわしく、ご迷惑をおかけする事例もあったよ
      うですので、プロトタイプフォルダのexeも AIMSd.exe にしました。あわせて、
      アプリケーションコンフィグもAIMSd.luaに名称変更しています。リリースの際は
      bin/フォルダからAIMS.exeをコピーし、ファイル名をご自身で変更ください。

2011/11/21(SVN掲載) v1.61
  ・不具合修正のみ。
    ・MOVER_MOVETO_* のdurationに1フレームを指定すると移動先がおかしくなるバグに
      対処。

2011/10/24(SVN掲載) v1.60
  PDFドキュメントの更新がまだなのですが、速報版としてSVNのみ更新します。
  東方幻想麻雀3rdGenerationで使用したバージョンとなります。

  ●重要な変更
    AIMSの仕様レベルに関わる変更が２点存在します。

    ・シーンスクリプトのOnStart、OnStep、OnCloseが【コルーチン扱いになった】。

    簡単に言うとシーンクラスの各関数でwait()関数が使えるようになったということ
    です。これまで別途コルーチンを呼んでいたような処理の多くがシーンクラスで
    まとめて記述できるようになることが期待されます。
    互換性については万全を期しましたが予期せぬ不具合が出るかもしれません。
    十分ご注意ください。

    ・シーンあたりレイヤーの最大数が12枚から16枚になった

    書いてあるとおりです。これまでのスクリプトをそのまま動かす分には一切影響
    しないはずです。今後はレイヤー指定の範囲は0〜15となります。

  ●新規関数追加
    1件のみ。
    ・imod(a,b) つねに正を返すmod演算です。

  ●既存関数の仕様変更
    ・stopIMEInputに引数1つ追加。
      stopIMEInput(flag)
      flag ... 入力を捨てるかそこで確定にさせるかの選択。
      trueで保持。falseで捨てる。省略時は捨てる（これまでの挙動）

  ●不具合修正・仕様に関わる変更
    ・テクスチャフォントの文字詰めを改良。テクスチャフォントを使っている場合
      バージョンアップ後は文字列の幅が少し変わります。
    ・キャラクターマップのブレンド指定がその直前に描いたアクターのブレンド設定に
      引きずられる不具合を修正。
    ・getTextWidth関数の戻り値が正しくない場合があったのを修正

2011/04/20 v1.51
  ・不具合修正のみです。
    ・setLayerFastDrawでZソートを行った際にアクターのグラフィックが頻繁に
      欠けたり残ったりする不具合に対処。
    ・playSoundの第二引数と第三引数がマニュアルと逆だったのをマニュアルに
      合わせた。
    ・drawGraphicListについて、レイヤーオフセットが正負逆に反映されていた件を
      修正

2011/03/30 v1.50
  ・以下の関数を追加。詳しくはPDFマニュアルで。
    ・setMouseClippingRect  ……  マウスの移動範囲を制限する
    ・randfMT  ……  常に実数を返す randMT
    ・getTextureFontHeight  ……  テクスチャフォントの「文字高」を得る。
    ・mapBlockTransfer  ……  テーブルからキャラクタマップへコピー
    ・getNearestActor  ……  最近傍のアクターを得る
    ・drawGraphic3DPlane,drawGraphicTorus,drawGraphicRing
          ……  特殊形状描画をOnDrawで
  ・drawTextureFont関数で文字整列を指定できるようになった。
  ・createTextActorで生成したテクスチャフォントアクターについても、文字間隔の
    処理が適切に働くようにFIX(VAR[64]で指定)
  ・一番最初に生成したテクスチャフォントだけがdrawTextureFontで使えなかった
    バグに対処
  ・drawTextureFontでテクスチャフォントを使ったとき、ALIGN_CENTERで描画座標が
    ズレるのを修正
  ・setHitOverrideで当たり判定の上書きが正しくなされない問題に対処
  ・開発版でF5を押してリスタートした際、ASCII文字フォントのテーブルをリセット
    していなかったのを修正。

  ・マップエディタとオートマップチップ変換ツールのClickOnceを使用しないように
    した
  （インストール先が不明瞭なのがどうも気になったのと、
    バージョンアップ処理で面倒をおかけしそうな感じだったのでやめました。
    コロコロ方針が変わって申し訳ありません）

  ・マップエディタ修正。
    ・無駄な再描画を抑制するようにした
    ・ペーストペンを使ったとき、オートマップの設定に関係なく常にオートマップの
      処理が入ってしまう不具合を修正。

  ・テクスチャフォント生成ツールのFontUtilをLuna最終版同梱のものをベースに更新。
    OpenTypeのフォントでよくみられる、「指定したピクセル数に対して得られるフォ
    ントのサイズが3割〜4割小さい」問題に対応できるようになっています。
    代わりに出力形式が若干減ってしまっていますが、アルファ付きPNGは出力できるの
    でとりあえずは問題無いと考えております。


2011/01/19 v1.42
  ・高速描画モードにおいて、アクターの描画順序が逆になっていた問題を修正。
  ・proto/common.luaに必要な定数定義が入っていなかったのを修正。
  ・マップエディタとオートマップチップ変換ツールについて、インストールにClickOnceを使うように変更。

2011/01/06 v1.41
  ・isWindowed 関数がなかった(isWindowModeという名前だった)
    isWindowed() でも isWindowMode() でも同様にウィンドウモードかどうかを得ら
    れるようにした。
  ・描画リストにおいて隣接したアクターを同時にVanishすると、一方のアクターの消去が１フレーム遅れ、OnVanish関数が二度呼ばれることがあったのを修正。
  （同一レイヤーで同一タイミングに生成したアクターが同時に消滅すると、この事例がたびたび発生します）

2010/12/23 v1.40
  ・アクターの変形描画時(VAR[64]=1,2,3)に起こる下記の不具合をFIX
    ・テクスチャが左右反転して貼り付けられてしまっていた(反転しないようにした)
    ・X,Y,Zで回転方向が統一できていなかった(すべて時計回りに)
  ・MPPSDK.dllによるMOD再生に対応。次の手順で有効化します。
    （リファレンスが間に合ってません。ごめんなさい）
    １．アプリケーションコンフィグに"USE_MODPLUG = 1"を書き加える
    ２．AIMS本体のEXEファイルと同じところにMPPSDK.dllを置く
        (パッケージに同梱してます)
    ここまでで有効化されます。
    再生は  playMod("ファイル名");
    ループ再生は  playModLoop("ファイル名");
    停止などはstopMusic(); fadeMusic();が使えます。
    MODPlug Trackerで作ったファイルならだいたい正しく鳴るはずです。
    ループ設定もMODファイルの設定を適用します。

    USE_MODPLUG=0を指定、または省略してあれば、MPPSDK.dllの同梱は不要です。

    （積極的に使われる方もそうそういないと思いますが）本機能はまだ検証が不足して
    いるところもありますので、不具合が出た場合はお知らせください。

2010/11/02 v1.30
  ・プレイヤー人数を最大8人まで設定可能に。ゲームパッドを準備できなかったので、
    パッド8つを接続した場合の動作は確認できていません。ご注意ください。
  ・キャラクターマップ機能、テクスチャフォントなどを正式な公開機能に
  ・getMouseW()関数の戻り値仕様を変更。前フレームからの相対値にした
  ・アクターにベクトルを設定したあと、getAngle、getSpeedの値がベクトルから
    導出した値に正しく再計算されるよう修正。
  ・他、一部関数で仕様通りの動作になっていなかったのを修正
    上記2関数以外に互換性に大きく関わるような修正はありません。
  ・リファレンスマニュアルをPDF化。一応、全機能の仕様を掲載しています。
  ・キャラクターマップ、テクスチャフォントのリリースに伴いマップエディタと
    テクスチャフォント生成ツールを同梱。テクスチャフォントに関わるFontUtilと
    そのフォントを梱包するLagUtilは葉迩倭氏制作のツールです。

2010/07/27 v1.20
  ・様々な修正が入った最新バージョンにアップデート

2008/12/27 v1.01
  ・リリース版においてAccess Violationで落ちる不具合があったので対処
  ・F11で表示されるデバッグログ表示を若干変更。
  ・デバッグ回りのオプション変更。(起動オプションの項参照のこと)

2008/09/27 v1.00
  ・公開初版
